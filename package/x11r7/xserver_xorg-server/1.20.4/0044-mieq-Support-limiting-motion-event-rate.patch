From c1088ff5348c2fe756ef2f758059b0dcf156b88e Mon Sep 17 00:00:00 2001
From: Jeffy Chen <jeffy.chen@rock-chips.com>
Date: Wed, 21 Aug 2019 16:55:58 +0800
Subject: [PATCH 44/47] mieq: Support limiting motion event rate

High motion event rate would affect the performance of window
moving/resizing.

Let's set the default rate to 60 events per second, and use env
"X_MAX_MOTION_RATE" to change it.

Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
---
 include/Makefile.am |  1 +
 include/inputstr.h  |  6 ++++
 mi/mieq.c           | 94 +++++++++++++++++++++++++++++++++++++++++++++++++++--
 3 files changed, 99 insertions(+), 2 deletions(-)

diff --git a/include/Makefile.am b/include/Makefile.am
index 9c22ce113..c892ba9a5 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -19,6 +19,7 @@ sdk_HEADERS =		\
 	dixgrabs.h	\
 	dixstruct.h	\
 	events.h	\
+	eventstr.h	\
 	exevents.h	\
 	extension.h	\
 	extinit.h	\
diff --git a/include/inputstr.h b/include/inputstr.h
index bf35dbf4b..9b01aa67f 100644
--- a/include/inputstr.h
+++ b/include/inputstr.h
@@ -531,6 +531,9 @@ typedef struct _SpriteInfoRec {
 #define KEYBOARD_OR_FLOAT       5       /* Keyboard master for this device or this device if floating */
 #define POINTER_OR_FLOAT        6       /* Pointer master for this device or this device if floating */
 
+#include "events.h"
+#include "eventstr.h"
+
 typedef struct _DeviceIntRec {
     DeviceRec public;
     DeviceIntPtr next;
@@ -602,6 +605,9 @@ typedef struct _DeviceIntRec {
     int xtest_master_id;
 
     struct _SyncCounter *idle_counter;
+
+    InternalEvent lastMotionEvent;
+    CARD32 lastMotionTime;
 } DeviceIntRec;
 
 typedef struct {
diff --git a/mi/mieq.c b/mi/mieq.c
index 555f0ec7e..124d41b4d 100644
--- a/mi/mieq.c
+++ b/mi/mieq.c
@@ -65,6 +65,7 @@ in this Software without prior written authorization from The Open Group.
 #define QUEUE_MAXIMUM_SIZE                4096
 #define QUEUE_DROP_BACKTRACE_FREQUENCY     100
 #define QUEUE_DROP_BACKTRACE_MAX            10
+#define QUEUE_CACHED_SIZE                   32
 
 #define EnqueueScreen(dev) dev->spriteInfo->sprite->pEnqueueScreen
 #define DequeueScreen(dev) dev->spriteInfo->sprite->pDequeueScreen
@@ -83,6 +84,8 @@ typedef struct _EventQueue {
     size_t nevents;             /* the number of buckets in our queue */
     size_t dropped;             /* counter for number of consecutive dropped events */
     mieqHandler handlers[128];  /* custom event handler */
+    int motionLimitMs;          /* min duration of motion events */
+    EventRec motionEvents[QUEUE_CACHED_SIZE];   /* cached motion event queue as an array */
 } EventQueueRec, *EventQueuePtr;
 
 static EventQueueRec miEventQueue;
@@ -160,9 +163,21 @@ mieqGrowQueue(EventQueuePtr eventQueue, size_t new_nevents)
 Bool
 mieqInit(void)
 {
+    char *env;
+    int maxMotionRate;
+
     memset(&miEventQueue, 0, sizeof(miEventQueue));
     miEventQueue.lastEventTime = GetTimeInMillis();
 
+    env = getenv("X_MAX_MOTION_RATE");
+    if (env && env[0])
+        maxMotionRate = atoi(env);
+    else
+        maxMotionRate = 60;
+
+    if (maxMotionRate > 0)
+        miEventQueue.motionLimitMs = 1000 / maxMotionRate;
+
     input_lock();
     if (!mieqGrowQueue(&miEventQueue, QUEUE_INITIAL_SIZE))
         FatalError("Could not allocate event queue.\n");
@@ -497,15 +512,57 @@ mieqProcessDeviceEvent(DeviceIntPtr dev, InternalEvent *event, ScreenPtr screen)
     }
 }
 
+static EventPtr
+mieqGetMotionEvent(DeviceIntPtr dev)
+{
+    EventRec *e = NULL, *motion;
+    int i;
+
+    motion = NULL;
+    for (i = 0; i < QUEUE_CACHED_SIZE; i++) {
+        e = &miEventQueue.motionEvents[i];
+        if (!motion && !e->pDev) {
+            motion = e;
+            continue;
+        }
+
+        if (e->pDev != dev)
+            continue;
+
+        motion = e;
+        break;
+    }
+
+    return motion;
+}
+
+static Bool
+mieqMotionEventReady(EventRec *e)
+{
+    InternalEvent event;
+    DeviceIntPtr dev;
+
+    if (!e || !e->pDev)
+        return FALSE;
+
+    event = *e->events;
+    dev = e->pDev;
+
+    return event.any.time - dev->lastMotionTime >= miEventQueue.motionLimitMs;
+}
+
 /* Call this from ProcessInputEvents(). */
 void
 mieqProcessInputEvents(void)
 {
-    EventRec *e = NULL;
+    EventRec *e = NULL, *motion;
     ScreenPtr screen;
     InternalEvent event;
     DeviceIntPtr dev = NULL, master = NULL;
     static Bool inProcessInputEvents = FALSE;
+    unsigned int oldtail = miEventQueue.tail;
+    unsigned int oldhead;
+    int i;
 
     input_lock();
 
@@ -525,15 +582,35 @@ mieqProcessInputEvents(void)
         miEventQueue.dropped = 0;
     }
 
-    while (miEventQueue.head != miEventQueue.tail) {
+    while (miEventQueue.head != oldtail) {
         e = &miEventQueue.events[miEventQueue.head];
 
         event = *e->events;
         dev = e->pDev;
         screen = e->pScreen;
 
+        oldhead = miEventQueue.head;
         miEventQueue.head = (miEventQueue.head + 1) % miEventQueue.nevents;
 
+        motion = mieqGetMotionEvent(dev);
+        if (motion) {
+            if (event.any.type == ET_Motion) {
+                if (!mieqMotionEventReady(e)) {
+                    // cache new motion event
+                    *motion = *e;
+                    continue;
+                }
+
+                // clear cached motion
+                motion->pDev = NULL;
+            } else if (event.any.type != ET_RawMotion && motion->pDev) {
+                // inject cached motion event before other events
+                event = *motion->events;
+                motion->pDev = NULL;
+                miEventQueue.head = oldhead;
+            }
+        }
+
         input_unlock();
 
         master = (dev) ? GetMaster(dev, MASTER_ATTACHED) : NULL;
@@ -550,6 +627,9 @@ mieqProcessInputEvents(void)
 
         mieqProcessDeviceEvent(dev, &event, screen);
 
+        if (event.any.type == ET_Motion)
+            dev->lastMotionTime = event.any.time;
+
         /* Update the sprite now. Next event may be from different device. */
         if (master &&
             (event.any.type == ET_Motion ||
@@ -563,5 +643,15 @@ mieqProcessInputEvents(void)
 
     inProcessInputEvents = FALSE;
 
+    // re-post cached motion events
+    for (i = 0; i < QUEUE_CACHED_SIZE; i++) {
+        e = &miEventQueue.motionEvents[i];
+        if (!mieqMotionEventReady(e))
+            continue;
+
+        mieqEnqueue(e->pDev, e->events);
+        e->pDev = NULL;
+    }
+
     input_unlock();
 }
-- 
2.11.0

