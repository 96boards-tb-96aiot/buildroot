From 40dbf4dbc38cf631a99b8d42e9508a623ab6681e Mon Sep 17 00:00:00 2001
From: Jeffy Chen <jeffy.chen@rock-chips.com>
Date: Mon, 26 Aug 2019 09:51:43 +0800
Subject: [PATCH 45/46] modetest: exa: Support xv for NV12

Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
---
 hw/xfree86/drivers/modesetting/Makefile.am       |   1 +
 hw/xfree86/drivers/modesetting/driver.c          |  11 +
 hw/xfree86/drivers/modesetting/driver.h          |   5 +
 hw/xfree86/drivers/modesetting/drmmode_display.c |   5 +-
 hw/xfree86/drivers/modesetting/drmmode_display.h |   4 +
 hw/xfree86/drivers/modesetting/exa.c             |  75 ++++++-
 hw/xfree86/drivers/modesetting/xv.c              | 256 +++++++++++++++++++++++
 7 files changed, 351 insertions(+), 6 deletions(-)
 create mode 100644 hw/xfree86/drivers/modesetting/xv.c

diff --git a/hw/xfree86/drivers/modesetting/Makefile.am b/hw/xfree86/drivers/modesetting/Makefile.am
index c1e3ccb5a..13b6c171d 100644
--- a/hw/xfree86/drivers/modesetting/Makefile.am
+++ b/hw/xfree86/drivers/modesetting/Makefile.am
@@ -55,6 +55,7 @@ modesetting_drv_la_SOURCES = \
 	 vblank.c \
 	 pageflip.c \
 	 exa.c \
+	 xv.c \
 	 $(NULL)
 
 drivermandir = $(DRIVER_MAN_DIR)
diff --git a/hw/xfree86/drivers/modesetting/driver.c b/hw/xfree86/drivers/modesetting/driver.c
index 24ed742e9..89ff097f4 100644
--- a/hw/xfree86/drivers/modesetting/driver.c
+++ b/hw/xfree86/drivers/modesetting/driver.c
@@ -1781,6 +1781,17 @@ ScreenInit(ScreenPtr pScreen, int argc, char **argv)
     }
 #endif
 
+    if (ms->drmmode.exa) {
+        XF86VideoAdaptorPtr     adaptor;
+
+        adaptor = ms_xv_init(pScreen, 16);
+        if (adaptor != NULL)
+            xf86XVScreenInit(pScreen, &adaptor, 1);
+        else
+            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                       "Failed to initialize XV support.\n");
+    }
+
     if (serverGeneration == 1)
         xf86ShowUnusedOptions(pScrn->scrnIndex, pScrn->options);
 
diff --git a/hw/xfree86/drivers/modesetting/driver.h b/hw/xfree86/drivers/modesetting/driver.h
index 5e6768b8b..92cb389f8 100644
--- a/hw/xfree86/drivers/modesetting/driver.h
+++ b/hw/xfree86/drivers/modesetting/driver.h
@@ -197,3 +197,8 @@ Bool ms_set_pixmap_bo(ScrnInfoPtr scrn, PixmapPtr pPixmap,
                       struct dumb_bo *bo, Bool owned);
 Bool ms_prepare_access(PixmapPtr pPix, int index);
 void ms_finish_access(PixmapPtr pPix, int index);
+
+Bool ms_copy_area(PixmapPtr pSrc, PixmapPtr pDst,
+                  pixman_f_transform_t *transform, RegionPtr clip);
+
+XF86VideoAdaptorPtr ms_xv_init(ScreenPtr screen, int num_texture_ports);
diff --git a/hw/xfree86/drivers/modesetting/drmmode_display.c b/hw/xfree86/drivers/modesetting/drmmode_display.c
index b22cefdb6..65b490505 100644
--- a/hw/xfree86/drivers/modesetting/drmmode_display.c
+++ b/hw/xfree86/drivers/modesetting/drmmode_display.c
@@ -54,9 +54,6 @@
 #include "driver.h"
 
 static Bool drmmode_xf86crtc_resize(ScrnInfoPtr scrn, int width, int height);
-static PixmapPtr drmmode_create_pixmap_header(ScreenPtr pScreen, int width, int height,
-                                              int depth, int bitsPerPixel, int devKind,
-                                              void *pPixData);
 
 static void drmmode_destroy_flip_fb(xf86CrtcPtr crtc);
 static Bool drmmode_create_flip_fb(xf86CrtcPtr crtc);
@@ -1844,7 +1841,7 @@ drmmode_shadow_allocate(xf86CrtcPtr crtc, int width, int height)
     return drmmode_crtc->rotate_bo.dumb;
 }
 
-static PixmapPtr
+PixmapPtr
 drmmode_create_pixmap_header(ScreenPtr pScreen, int width, int height,
                              int depth, int bitsPerPixel, int devKind,
                              void *pPixData)
diff --git a/hw/xfree86/drivers/modesetting/drmmode_display.h b/hw/xfree86/drivers/modesetting/drmmode_display.h
index a157d2f4c..a13ca4d55 100644
--- a/hw/xfree86/drivers/modesetting/drmmode_display.h
+++ b/hw/xfree86/drivers/modesetting/drmmode_display.h
@@ -317,4 +317,8 @@ void drmmode_set_dpms(ScrnInfoPtr scrn, int PowerManagementMode, int flags);
 
 Bool drmmode_flip_fb(xf86CrtcPtr crtc, int *timeout);
 
+PixmapPtr drmmode_create_pixmap_header(ScreenPtr pScreen, int width, int height,
+                                       int depth, int bitsPerPixel, int devKind,
+                                       void *pPixData);
+
 #endif
diff --git a/hw/xfree86/drivers/modesetting/exa.c b/hw/xfree86/drivers/modesetting/exa.c
index e0c2fc82e..76ea46109 100644
--- a/hw/xfree86/drivers/modesetting/exa.c
+++ b/hw/xfree86/drivers/modesetting/exa.c
@@ -78,6 +78,8 @@ rga_get_pixmap_format(PixmapPtr pPix)
         return RK_FORMAT_RGBA_8888;
     case 16:
         return RK_FORMAT_RGB_565;
+    case 12:
+        return RK_FORMAT_YCrCb_420_SP;
     default:
         return RK_FORMAT_UNKNOWN;
     }
@@ -104,10 +106,19 @@ rga_prepare_info(PixmapPtr pPixmap, rga_info_t *info,
         pitch = pPixmap->devKind;
     }
 
+    format = rga_get_pixmap_format(pPixmap);
+
+    /* rga requires yuv image rect align to 2 */
+    if (format == RK_FORMAT_YCrCb_420_SP) {
+        x = (x + 1) & ~1;
+        y = (y + 1) & ~1;
+        w = w & ~1;
+        h = h & ~1;
+    }
+
     rga_set_rect(&info->rect, x, y, w, h,
                  pitch * 8 / pPixmap->drawable.bitsPerPixel,
-                 pPixmap->drawable.height,
-                 rga_get_pixmap_format(pPixmap));
+                 pPixmap->drawable.height, format);
 }
 
 static Bool
@@ -812,3 +823,63 @@ ms_set_pixmap_bo(ScrnInfoPtr scrn, PixmapPtr pPixmap,
 
     return TRUE;
 }
+
+// TODO: Add bail func
+Bool
+ms_copy_area(PixmapPtr pSrc, PixmapPtr pDst,
+             pixman_f_transform_t *transform, RegionPtr clip)
+{
+#ifndef MODESETTING_WITH_RGA
+    return FALSE;
+#else
+    rga_info_t src_info = {0};
+    rga_info_t dst_info = {0};
+    RegionPtr region = RegionDuplicate(clip);
+    BoxPtr box = REGION_RECTS(region);
+    int n = REGION_NUM_RECTS(region);
+
+    if (!rga_check_pixmap(pSrc))
+        return FALSE;
+
+    if (!rga_check_pixmap(pDst))
+        return FALSE;
+
+    while(n--) {
+        int sx, sy, sw, sh, dx, dy, dw, dh;
+
+        dx = box->x1;
+        dy = box->y1;
+        dw = box->x2 - box->x1;
+        dh = box->y2 - box->y1;
+
+        pixman_f_transform_bounds(transform, box);
+
+        sx = max(box->x1, 0);
+        sy = max(box->y1, 0);
+        sw = min(box->x2, pSrc->drawable.width) - sx;
+        sh = min(box->y2, pSrc->drawable.height) - sy;
+
+        /* rga requires image width/height larger than 2 */
+        if (sw <= 2 || sh <= 2 || dw <= 2 || dh <= 2)
+            continue;
+
+        /* rga has scale limits */
+        if ((double)sw / dw > 16 || (double)dw / sw > 16 ||
+            (double)sh / dh > 16 || (double)dh / sh > 16)
+            continue;
+
+        rga_prepare_info(pSrc, &src_info, sx, sy, sw, sh);
+        rga_prepare_info(pDst, &dst_info, dx, dy, dw, dh);
+
+        if (c_RkRgaBlit(&src_info, &dst_info, NULL) < 0) {
+            RegionDestroy(region);
+            return FALSE;
+        }
+
+        box++;
+    }
+
+    RegionDestroy(region);
+    return TRUE;
+#endif
+}
diff --git a/hw/xfree86/drivers/modesetting/xv.c b/hw/xfree86/drivers/modesetting/xv.c
new file mode 100644
index 000000000..ea4760c5a
--- /dev/null
+++ b/hw/xfree86/drivers/modesetting/xv.c
@@ -0,0 +1,256 @@
+/*
+ *  Copyright (c) 2019, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include "dix-config.h"
+#endif
+
+#include "driver.h"
+#include "dumb_bo.h"
+/*
+#include "xf86.h"
+*/
+
+#include <stdio.h>
+#include <unistd.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <libdrm/drm_fourcc.h>
+
+#include <X11/extensions/Xv.h>
+#include "fourcc.h"
+
+#define NUM_FORMATS 4
+
+static XF86VideoFormatRec Formats[NUM_FORMATS] = {
+    {15, TrueColor}, {16, TrueColor}, {24, TrueColor}, {30, TrueColor}
+};
+
+#define MAKE_ATOM(a) MakeAtom(a, sizeof(a) - 1, TRUE)
+
+XvAttributeRec ms_xv_attributes[] = {
+    {0, 0, 0, NULL}
+};
+int ms_xv_num_attributes = ARRAY_SIZE(ms_xv_attributes) - 1;
+
+XvImageRec ms_xv_images[] = {
+    XVIMAGE_NV12
+};
+int ms_xv_num_images = ARRAY_SIZE(ms_xv_images);
+
+#define ALIGN(i,m) (((i) + (m) - 1) & ~((m) - 1))
+
+typedef struct {
+} ms_port_private;
+
+static void
+ms_xv_stop_video(ScrnInfoPtr pScrn, void *data, Bool cleanup)
+{
+}
+
+static int
+ms_xv_set_port_attribute(ScrnInfoPtr pScrn,
+                         Atom attribute, INT32 value, void *data)
+{
+    return Success;
+}
+
+static int
+ms_xv_get_port_attribute(ScrnInfoPtr pScrn,
+                         Atom attribute, INT32 *value, void *data)
+{
+    return Success;
+}
+
+static void
+ms_xv_query_best_size(ScrnInfoPtr pScrn,
+                      Bool motion,
+                      short vid_w, short vid_h,
+                      short drw_w, short drw_h,
+                      unsigned int *p_w, unsigned int *p_h, void *data)
+{
+    *p_w = drw_w;
+    *p_h = drw_h;
+}
+
+static int
+ms_xv_query_image_attributes(ScrnInfoPtr pScrn,
+                             int id,
+                             unsigned short *w, unsigned short *h,
+                             int *pitches, int *offsets)
+{
+    int size = 0, tmp;
+
+    if (offsets)
+        offsets[0] = 0;
+
+    if (id != FOURCC_NV12)
+        return 0;
+
+    *w = ALIGN(*w, 2);
+    *h = ALIGN(*h, 2);
+    size = ALIGN(*w, 4);
+    if (pitches)
+        pitches[0] = size;
+    size *= *h;
+    if (offsets)
+        offsets[1] = offsets[2] = size;
+    tmp = ALIGN(*w, 4);
+    if (pitches)
+        pitches[1] = pitches[2] = tmp;
+    tmp *= (*h >> 1);
+    size += tmp;
+
+    return size;
+}
+
+static PixmapPtr
+ms_xv_create_pixmap(ScrnInfoPtr scrn, ms_port_private *port_priv,
+                    int id,
+                    unsigned char *buf,
+                    short width,
+                    short height)
+{
+    ScreenPtr screen = scrn->pScreen;
+    PixmapPtr pixmap;
+    int pitch;
+
+    pitch = ALIGN(width, 4) * 3 / 2;
+
+    pixmap = drmmode_create_pixmap_header(screen, width, height,
+                                          12, 12, pitch, buf);
+    if (!pixmap)
+        return NULL;
+
+    pixmap->devKind = pitch;
+    pixmap->devPrivate.ptr = buf;
+
+    return pixmap;
+}
+
+    static int
+ms_xv_put_image(ScrnInfoPtr pScrn,
+                short src_x, short src_y,
+                short drw_x, short drw_y,
+                short src_w, short src_h,
+                short drw_w, short drw_h,
+                int id,
+                unsigned char *buf,
+                short width,
+                short height,
+                Bool sync,
+                RegionPtr clipBoxes, void *data, DrawablePtr pDrawable)
+{
+    ms_port_private *port_priv = data;
+    ScreenPtr screen = pScrn->pScreen;
+    PixmapPtr src_pixmap, dst_pixmap;
+    pixman_f_transform_t transform;
+    double sx, sy, tx, ty;
+    int ret = Success;
+
+    src_pixmap = ms_xv_create_pixmap(pScrn, port_priv, id,
+                                     buf, width, height);
+    if (!src_pixmap)
+        return BadMatch;
+
+    if (pDrawable->type == DRAWABLE_WINDOW)
+        dst_pixmap = screen->GetWindowPixmap((WindowPtr) pDrawable);
+    else
+        dst_pixmap = (PixmapPtr) pDrawable;
+
+    DamageRegionAppend(pDrawable, clipBoxes);
+
+    sx = (double)src_w / drw_w;
+    sy = (double)src_h / drw_h;
+
+#ifdef COMPOSITOR
+    tx = dst_pixmap->screen_x - pDrawable->x;
+    ty = dst_pixmap->screen_y - pDrawable->y;
+
+    RegionTranslate(clipBoxes, -dst_pixmap->screen_x, -dst_pixmap->screen_y);
+#else
+    tx = 0;
+    ty = 0;
+#endif
+    tx += drw_x - src_x;
+    ty += drw_y - src_y;
+
+    pixman_f_transform_init_scale(&transform, sx, sy);
+    pixman_f_transform_translate(NULL, &transform, tx, ty);
+
+    if (!ms_copy_area(src_pixmap, dst_pixmap, &transform, clipBoxes))
+        ret = BadMatch;
+
+    DamageRegionProcessPending(pDrawable);
+
+    screen->DestroyPixmap(src_pixmap);
+
+    return ret;
+}
+
+static XF86VideoEncodingRec DummyEncoding[1] = {
+    { 0, "XV_IMAGE", 8192, 8192, {1, 1} }
+};
+
+XF86VideoAdaptorPtr
+ms_xv_init(ScreenPtr screen, int num_texture_ports)
+{
+    ms_port_private *port_priv;
+    XF86VideoAdaptorPtr adapt;
+    int i;
+
+    adapt = calloc(1, sizeof(XF86VideoAdaptorRec) + num_texture_ports *
+                   (sizeof(ms_port_private) + sizeof(DevUnion)));
+    if (adapt == NULL)
+        return NULL;
+
+    adapt->type = XvWindowMask | XvInputMask | XvImageMask;
+    adapt->flags = 0;
+    adapt->name = "Modesetting Textured Video";
+    adapt->nEncodings = 1;
+    adapt->pEncodings = DummyEncoding;
+
+    adapt->nFormats = NUM_FORMATS;
+    adapt->pFormats = Formats;
+    adapt->nPorts = num_texture_ports;
+    adapt->pPortPrivates = (DevUnion *) (&adapt[1]);
+
+    adapt->pAttributes = ms_xv_attributes;
+    adapt->nAttributes = ms_xv_num_attributes;
+
+    port_priv =
+        (ms_port_private *) (&adapt->pPortPrivates[num_texture_ports]);
+
+    adapt->pImages = ms_xv_images;
+    adapt->nImages = ms_xv_num_images;
+
+    adapt->PutVideo = NULL;
+    adapt->PutStill = NULL;
+    adapt->GetVideo = NULL;
+    adapt->GetStill = NULL;
+    adapt->StopVideo = ms_xv_stop_video;
+    adapt->SetPortAttribute = ms_xv_set_port_attribute;
+    adapt->GetPortAttribute = ms_xv_get_port_attribute;
+    adapt->QueryBestSize = ms_xv_query_best_size;
+    adapt->PutImage = ms_xv_put_image;
+    adapt->ReputImage = NULL;
+    adapt->QueryImageAttributes = ms_xv_query_image_attributes;
+
+    for (i = 0; i < num_texture_ports; i++) {
+        ms_port_private *priv = &port_priv[i];
+
+        adapt->pPortPrivates[i].ptr = (void *) (priv);
+    }
+    return adapt;
+}
-- 
2.11.0

